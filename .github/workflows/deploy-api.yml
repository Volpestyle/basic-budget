name: Deploy API

on:
  workflow_run:
    workflows: ["Deploy Infrastructure"]
    types: [completed]
    branches: [main, develop]
  push:
    branches: [main, develop]
    paths:
      - 'packages/api/**'
      - '.github/workflows/deploy-api.yml'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'dev'
        type: choice
        options:
        - dev
        - staging
        - prod

env:
  AWS_REGION: us-east-1
  NODE_VERSION: '20'

jobs:
  determine-environment:
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.set-env.outputs.environment }}
      should-deploy: ${{ steps.set-env.outputs.should-deploy }}
    steps:
      - name: Determine environment and deployment
        id: set-env
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "environment=${{ inputs.environment }}" >> $GITHUB_OUTPUT
            echo "should-deploy=true" >> $GITHUB_OUTPUT
          elif [[ "${{ github.event_name }}" == "workflow_run" ]]; then
            if [[ "${{ github.event.workflow_run.head_branch }}" == "main" ]]; then
              echo "environment=prod" >> $GITHUB_OUTPUT
            elif [[ "${{ github.event.workflow_run.head_branch }}" == "develop" ]]; then
              echo "environment=staging" >> $GITHUB_OUTPUT
            else
              echo "environment=dev" >> $GITHUB_OUTPUT
            fi
            echo "should-deploy=${{ github.event.workflow_run.conclusion == 'success' }}" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            echo "environment=prod" >> $GITHUB_OUTPUT
            echo "should-deploy=true" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref }}" == "refs/heads/develop" ]]; then
            echo "environment=staging" >> $GITHUB_OUTPUT
            echo "should-deploy=true" >> $GITHUB_OUTPUT
          else
            echo "environment=dev" >> $GITHUB_OUTPUT
            echo "should-deploy=true" >> $GITHUB_OUTPUT
          fi

  test-and-build-api:
    runs-on: ubuntu-latest
    needs: determine-environment
    if: needs.determine-environment.outputs.should-deploy == 'true'
    defaults:
      run:
        working-directory: ./packages/api
    outputs:
      build-hash: ${{ steps.build-info.outputs.build-hash }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Bun
        uses: oven-sh/setup-bun@v1
        with:
          bun-version: 'latest'

      - name: Install dependencies
        run: bun install --frozen-lockfile

      - name: Run type checking
        run: bun run type-check || npx tsc --noEmit

      - name: Run linting
        run: bun run lint

      - name: Run unit tests
        run: bun test --coverage

      - name: Run security audit
        run: bun audit

      - name: Build application
        env:
          NODE_ENV: production
          ENVIRONMENT: ${{ needs.determine-environment.outputs.environment }}
        run: |
          bun run build

      - name: Generate build info
        id: build-info
        run: |
          BUILD_HASH=$(find dist -type f -exec sha256sum {} \; 2>/dev/null | sha256sum | cut -d' ' -f1 || echo "no-build-files")
          echo "build-hash=${BUILD_HASH}" >> $GITHUB_OUTPUT

      - name: Package for deployment
        run: |
          # Create deployment package
          mkdir -p deployment-package
          
          # Copy built files
          cp -r dist/* deployment-package/ 2>/dev/null || echo "No dist files to copy"
          
          # Copy package.json and lock file
          cp package.json deployment-package/
          cp bun.lockb deployment-package/ 2>/dev/null || echo "No bun.lockb found"
          
          # Install production dependencies
          cd deployment-package
          bun install --production --frozen-lockfile
          
          # Remove dev dependencies and unnecessary files
          rm -rf node_modules/.cache
          find node_modules -name "*.md" -delete
          find node_modules -name "test" -type d -exec rm -rf {} + 2>/dev/null || true
          find node_modules -name "tests" -type d -exec rm -rf {} + 2>/dev/null || true

      - name: Upload deployment package
        uses: actions/upload-artifact@v4
        with:
          name: api-deployment-${{ needs.determine-environment.outputs.environment }}
          path: packages/api/deployment-package/
          retention-days: 30

  deploy-api:
    runs-on: ubuntu-latest
    needs: [determine-environment, test-and-build-api]
    if: needs.determine-environment.outputs.should-deploy == 'true'
    environment:
      name: ${{ needs.determine-environment.outputs.environment }}
    permissions:
      id-token: write
      contents: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download deployment package
        uses: actions/download-artifact@v4
        with:
          name: api-deployment-${{ needs.determine-environment.outputs.environment }}
          path: ./deployment-package

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ vars.AWS_API_DEPLOYMENT_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: GitHubActions-ApiDeploy

      - name: Get Lambda function name
        id: get-function
        run: |
          FUNCTION_ARN=$(aws cloudformation describe-stacks \
            --stack-name "basic-budget-api-${{ needs.determine-environment.outputs.environment }}" \
            --query 'Stacks[0].Outputs[?OutputKey==`LambdaFunctionArn`].OutputValue' \
            --output text)
          
          FUNCTION_NAME=$(echo $FUNCTION_ARN | cut -d':' -f7)
          echo "function-name=${FUNCTION_NAME}" >> $GITHUB_OUTPUT

      - name: Create deployment package
        run: |
          cd deployment-package
          zip -r ../api-deployment.zip . -x "*.git*" "*.DS_Store*"

      - name: Deploy to Lambda
        id: deploy
        run: |
          # Update function code
          UPDATE_RESULT=$(aws lambda update-function-code \
            --function-name ${{ steps.get-function.outputs.function-name }} \
            --zip-file fileb://api-deployment.zip \
            --output json)
          
          # Extract the new version ARN
          VERSION_ARN=$(echo $UPDATE_RESULT | jq -r '.FunctionArn')
          echo "version-arn=${VERSION_ARN}" >> $GITHUB_OUTPUT
          
          # Wait for function to be updated
          aws lambda wait function-updated-v2 \
            --function-name ${{ steps.get-function.outputs.function-name }}

      - name: Update function configuration if needed
        run: |
          # Update environment variables if needed
          aws lambda update-function-configuration \
            --function-name ${{ steps.get-function.outputs.function-name }} \
            --environment Variables='{
              "NODE_ENV":"${{ needs.determine-environment.outputs.environment }}",
              "ENVIRONMENT":"${{ needs.determine-environment.outputs.environment }}",
              "VERSION":"${{ github.sha }}",
              "DEPLOYMENT_TIME":"$(date -u +%Y-%m-%dT%H:%M:%SZ)"
            }' || echo "Configuration update failed, continuing..."

      - name: Create or update alias
        run: |
          # Try to update the alias, create if it doesn't exist
          aws lambda update-alias \
            --function-name ${{ steps.get-function.outputs.function-name }} \
            --name "live" \
            --function-version '$LATEST' \
            --description "Live version for ${{ needs.determine-environment.outputs.environment }}" \
            2>/dev/null || \
          aws lambda create-alias \
            --function-name ${{ steps.get-function.outputs.function-name }} \
            --name "live" \
            --function-version '$LATEST' \
            --description "Live version for ${{ needs.determine-environment.outputs.environment }}"

      - name: Test API deployment
        run: |
          # Get API endpoint
          API_URL=$(aws cloudformation describe-stacks \
            --stack-name "basic-budget-api-${{ needs.determine-environment.outputs.environment }}" \
            --query 'Stacks[0].Outputs[?OutputKey==`ApiUrl`].OutputValue' \
            --output text)
          
          echo "Testing API at: ${API_URL}"
          
          # Wait a moment for propagation
          sleep 10
          
          # Test health endpoint
          HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "${API_URL}/api/health" || echo "000")
          
          if [[ "$HTTP_STATUS" == "200" ]]; then
            echo "✅ API deployment successful!"
            curl -s "${API_URL}/api/health" | jq . || echo "Health endpoint returned non-JSON response"
          else
            echo "❌ API health check failed (HTTP $HTTP_STATUS)"
            exit 1
          fi

      - name: Run integration tests
        continue-on-error: true
        run: |
          API_URL=$(aws cloudformation describe-stacks \
            --stack-name "basic-budget-api-${{ needs.determine-environment.outputs.environment }}" \
            --query 'Stacks[0].Outputs[?OutputKey==`ApiUrl`].OutputValue' \
            --output text)
          
          echo "Running integration tests against ${API_URL}"
          
          # Test basic endpoints
          curl -f "${API_URL}/api/health" > /dev/null && echo "✅ Health check passed"
          
          # Add more integration tests as needed
          echo "Integration tests completed"

      - name: Create deployment summary
        run: |
          API_URL=$(aws cloudformation describe-stacks \
            --stack-name "basic-budget-api-${{ needs.determine-environment.outputs.environment }}" \
            --query 'Stacks[0].Outputs[?OutputKey==`ApiUrl`].OutputValue' \
            --output text)
          
          cat >> $GITHUB_STEP_SUMMARY << EOF
          ## API Deployment Summary
          
          **Environment:** ${{ needs.determine-environment.outputs.environment }}
          **Build Hash:** ${{ needs.test-and-build-api.outputs.build-hash }}
          **Lambda Function:** ${{ steps.get-function.outputs.function-name }}
          **Version ARN:** ${{ steps.deploy.outputs.version-arn }}
          **API URL:** ${API_URL}
          
          ### Deployment Details
          - Lambda function code updated
          - Function configuration updated
          - Live alias updated to \$LATEST
          - Health check passed
          EOF

  notify-api-deployment:
    runs-on: ubuntu-latest
    needs: [determine-environment, deploy-api]
    if: always() && needs.determine-environment.outputs.should-deploy == 'true'
    steps:
      - name: Notify API deployment status
        run: |
          if [[ "${{ needs.deploy-api.result }}" == "success" ]]; then
            echo "✅ API deployment successful for ${{ needs.determine-environment.outputs.environment }}"
          else
            echo "❌ API deployment failed for ${{ needs.determine-environment.outputs.environment }}"
            exit 1
          fi